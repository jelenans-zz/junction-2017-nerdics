"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var webpack_1 = require("@ngtools/webpack");
var utils_1 = require("./utils");
var resource_loader_1 = require("./resource-loader");
function createAngularCompilerPluginExecutionHost(options) {
    var ngPlugin = new webpack_1.AngularCompilerPlugin(options);
    if (!utils_1.isValidAngularCompilerPlugin(ngPlugin)) {
        throw new Error('The "@ngtools/webpack" package installed is not compatible with this ' +
            'version of "ngc-webpack"');
    }
    // we must use the base instance because AngularCompilerPlugin use it.
    var compilerHost = ngPlugin._compilerHost;
    Object.defineProperty(compilerHost, 'resourceLoader', {
        get: function () {
            return this._resourceLoader;
        }
    });
    return {
        execute: function (compiler) {
            ngPlugin.apply(compiler);
        },
        compilerHost: compilerHost,
        transformers: ngPlugin._transformers,
        hookOverride: {
            readFileTransformer: function (readFileTransformer) {
                var orgReadFile = compilerHost.readFile;
                var predicate = readFileTransformer.predicate, transform = readFileTransformer.transform;
                var predicateFn = typeof predicate === 'function'
                    ? predicate
                    : function (fileName) { return predicate.test(fileName); };
                Object.defineProperty(compilerHost, 'readFile', {
                    value: function (fileName) {
                        if (predicateFn(fileName)) {
                            var stats = compilerHost._files[fileName];
                            if (!stats) {
                                var content = transform(fileName, orgReadFile.call(compilerHost, fileName));
                                stats = compilerHost._files[fileName];
                                if (stats) {
                                    stats.content = content;
                                }
                                return content;
                            }
                        }
                        return orgReadFile.call(compilerHost, fileName);
                    }
                });
            }
        }
    };
}
exports.createAngularCompilerPluginExecutionHost = createAngularCompilerPluginExecutionHost;
var NgcWebpackPlugin = (function () {
    function NgcWebpackPlugin(options, executionHostFactory) {
        if (executionHostFactory === void 0) { executionHostFactory = createAngularCompilerPluginExecutionHost; }
        if (options.hasOwnProperty('AOT')) {
            if (!options.hasOwnProperty('skipCodeGeneration')) {
                options.skipCodeGeneration = !options.AOT;
            }
            delete options.AOT;
        }
        this.ngcWebpackPluginOptions = options;
        this.executionHostFactory = executionHostFactory;
    }
    NgcWebpackPlugin.prototype.apply = function (compiler) {
        var ngcOptions = this.ngcWebpackPluginOptions;
        var executionHost = this.executionHostFactory(this.ngcWebpackPluginOptions);
        var compilerHost = executionHost.compilerHost;
        var executeHook = function (key, defaultHook) {
            if (ngcOptions[key]) {
                if (executionHost.hookOverride && executionHost.hookOverride[key]) {
                    executionHost.hookOverride[key](ngcOptions[key]);
                }
                else {
                    defaultHook(ngcOptions[key]);
                }
            }
        };
        executeHook('beforeRun', function (beforeRun) {
            var ran = false;
            var run = function (cmp, next) {
                if (ran) {
                    next();
                    return;
                }
                // for now, run once
                // TODO: add hook for watch mode to notify on watch-run
                ran = true;
                var webpackResourceLoader = new resource_loader_1.WebpackResourceLoader();
                webpackResourceLoader.update(compiler.createCompilation());
                Promise.resolve(beforeRun(webpackResourceLoader)).then(next).catch(next);
            };
            compiler.plugin('run', run);
            compiler.plugin('watch-run', run);
        });
        executeHook('readFileTransformer', function (opt) {
            var orgReadFile = compilerHost.readFile;
            var _a = ngcOptions.readFileTransformer, predicate = _a.predicate, transform = _a.transform;
            var predicateFn = typeof predicate === 'function'
                ? predicate
                : function (fileName) { return predicate.test(fileName); };
            Object.defineProperty(compilerHost, 'readFile', {
                value: function (fileName) {
                    var readFileResponse = orgReadFile.call(compilerHost, fileName);
                    return predicateFn(fileName) ? transform(fileName, readFileResponse) : readFileResponse;
                }
            });
        });
        if (ngcOptions.tsTransformers) {
            if (ngcOptions.tsTransformers.before) {
                (_a = executionHost.transformers).push.apply(_a, ngcOptions.tsTransformers.before);
            }
            if (ngcOptions.tsTransformers.after) {
            }
        }
        if (utils_1.hasHook(ngcOptions, ['resourcePathTransformer', 'resourceTransformer']).some(function (v) { return v; })) {
            var resourceGet_1 = compilerHost.resourceLoader.get;
            compilerHost.resourceLoader.get = function (filePath) {
                executeHook('resourcePathTransformer', function (pathTransformer) { return filePath = pathTransformer(filePath); });
                var p = resourceGet_1.call(compilerHost.resourceLoader, filePath);
                executeHook('resourceTransformer', function (resourceTransformer) { return p = p.then(function (content) { return Promise.resolve(resourceTransformer(filePath, content)); }); });
                return p;
            };
        }
        executionHost.execute(compiler);
        var _a;
    };
    NgcWebpackPlugin.clone = function (plugin, overwrite) {
        var options = Object.assign({}, plugin.ngcWebpackPluginOptions, overwrite.options || {});
        var executionHostFactory = overwrite.executionHostFactory || plugin.executionHostFactory;
        return new NgcWebpackPlugin(options, executionHostFactory);
    };
    return NgcWebpackPlugin;
}());
exports.NgcWebpackPlugin = NgcWebpackPlugin;
//# sourceMappingURL=plugin.js.map