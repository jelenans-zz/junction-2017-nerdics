"use strict";
/*  Copied from https://github.com/angular/angular/blob/master/packages/compiler-cli/src/perform_compile.ts
    but witch async support for program.loadNgStructureAsync()
 */
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var compiler_1 = require("@angular/compiler");
var compiler_cli_1 = require("@angular/compiler-cli");
function performCompilationAsync(_a) {
    var rootNames = _a.rootNames, options = _a.options, host = _a.host, oldProgram = _a.oldProgram, emitCallback = _a.emitCallback, _b = _a.gatherDiagnostics, gatherDiagnostics = _b === void 0 ? asyncDiagnostics : _b, customTransformers = _a.customTransformers, _c = _a.emitFlags, emitFlags = _c === void 0 ? compiler_cli_1.EmitFlags.Default : _c;
    var program;
    var emitResult;
    var allDiagnostics = [];
    return Promise.resolve()
        .then(function () {
        if (!host) {
            host = compiler_cli_1.createCompilerHost({ options: options });
        }
        program = compiler_cli_1.createProgram({ rootNames: rootNames, host: host, options: options, oldProgram: oldProgram });
        return program.loadNgStructureAsync();
    })
        .then(function () {
        var beforeDiags = Date.now();
        allDiagnostics.push.apply(allDiagnostics, gatherDiagnostics(program));
        if (options.diagnostics) {
            var afterDiags = Date.now();
            allDiagnostics.push(createMessageDiagnostic("Time for diagnostics: " + (afterDiags - beforeDiags) + "ms."));
        }
        if (!hasErrors(allDiagnostics)) {
            emitResult = program.emit({ emitCallback: emitCallback, customTransformers: customTransformers, emitFlags: emitFlags });
            allDiagnostics.push.apply(allDiagnostics, emitResult.diagnostics);
            return { diagnostics: allDiagnostics, program: program, emitResult: emitResult };
        }
        return { diagnostics: allDiagnostics, program: program };
    })
        .catch(function (e) {
        var errMsg;
        var code;
        if (compiler_1.isSyntaxError(e)) {
            // don't report the stack for syntax errors as they are well known errors.
            errMsg = e.message;
            code = compiler_cli_1.DEFAULT_ERROR_CODE;
        }
        else {
            errMsg = e.stack;
            // It is not a syntax error we might have a program with unknown state, discard it.
            program = undefined;
            code = compiler_cli_1.UNKNOWN_ERROR_CODE;
        }
        allDiagnostics.push({ category: ts.DiagnosticCategory.Error, messageText: errMsg, code: code, source: compiler_cli_1.SOURCE });
        return { diagnostics: allDiagnostics, program: program };
    });
}
exports.performCompilationAsync = performCompilationAsync;
function asyncDiagnostics(angularProgram) {
    var allDiagnostics = [];
    // Check Angular structural diagnostics.
    allDiagnostics.push.apply(allDiagnostics, angularProgram.getNgStructuralDiagnostics());
    // Check TypeScript parameter diagnostics.
    allDiagnostics.push.apply(allDiagnostics, angularProgram.getTsOptionDiagnostics());
    // Check Angular parameter diagnostics.
    allDiagnostics.push.apply(allDiagnostics, angularProgram.getNgOptionDiagnostics());
    function checkDiagnostics(diags) {
        if (diags) {
            allDiagnostics.push.apply(allDiagnostics, diags);
            return !hasErrors(diags);
        }
        return true;
    }
    var checkOtherDiagnostics = true;
    // Check TypeScript syntactic diagnostics.
    checkOtherDiagnostics = checkOtherDiagnostics &&
        checkDiagnostics(angularProgram.getTsSyntacticDiagnostics(undefined));
    // Check TypeScript semantic and Angular structure diagnostics.
    checkOtherDiagnostics = checkOtherDiagnostics &&
        checkDiagnostics(angularProgram.getTsSemanticDiagnostics(undefined));
    // Check Angular semantic diagnostics
    checkOtherDiagnostics = checkOtherDiagnostics &&
        checkDiagnostics(angularProgram.getNgSemanticDiagnostics(undefined));
    return allDiagnostics;
}
function defaultGatherDiagnostics(program) {
    var allDiagnostics = [];
    function checkDiagnostics(diags) {
        if (diags) {
            allDiagnostics.push.apply(allDiagnostics, diags);
            return !hasErrors(diags);
        }
        return true;
    }
    var checkOtherDiagnostics = true;
    // Check parameter diagnostics
    checkOtherDiagnostics = checkOtherDiagnostics &&
        checkDiagnostics(program.getTsOptionDiagnostics().concat(program.getNgOptionDiagnostics()));
    // Check syntactic diagnostics
    checkOtherDiagnostics =
        checkOtherDiagnostics && checkDiagnostics(program.getTsSyntacticDiagnostics());
    // Check TypeScript semantic and Angular structure diagnostics
    checkOtherDiagnostics =
        checkOtherDiagnostics &&
            checkDiagnostics(program.getTsSemanticDiagnostics().concat(program.getNgStructuralDiagnostics()));
    // Check Angular semantic diagnostics
    checkOtherDiagnostics =
        checkOtherDiagnostics && checkDiagnostics(program.getNgSemanticDiagnostics());
    return allDiagnostics;
}
function hasErrors(diags) {
    return diags.some(function (d) { return d.category === ts.DiagnosticCategory.Error; });
}
function createMessageDiagnostic(messageText) {
    return {
        file: undefined,
        start: undefined,
        length: undefined,
        category: ts.DiagnosticCategory.Message, messageText: messageText,
        code: compiler_cli_1.DEFAULT_ERROR_CODE,
        source: compiler_cli_1.SOURCE,
    };
}
//# sourceMappingURL=perform_compile_async.js.map