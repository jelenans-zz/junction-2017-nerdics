{"version":3,"file":"inline-resources.js","sourceRoot":"","sources":["../../../../src/cli/transformers/inline-resources.ts"],"names":[],"mappings":"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","sourcesContent":["// @ignoreDep typescript\nimport * as Path from 'path';\nimport * as ts from 'typescript';\n\nimport { collectDeepNodes } from './fw/ast_helpers';\nimport { makeTransform } from './fw/make_transform';\nimport {\n  StandardTransform,\n  ReplaceNodeOperation\n} from './fw/interfaces';\n\nexport function inlineResources(getResource: (resourcePath: string) => string | undefined,\n                                shouldTransform: (fileName: string) => boolean): ts.TransformerFactory<ts.SourceFile> {\n  const createInlineLiteral = createInlineLiteralFactory(getResource);\n  const standardTransform: StandardTransform = function (sourceFile: ts.SourceFile) {\n    if (!shouldTransform(sourceFile.fileName)) {\n      return [];\n    }\n    return findResources(sourceFile, createInlineLiteral);\n  };\n\n  return makeTransform(standardTransform);\n}\n\nexport function findResources(sourceFile: ts.SourceFile,\n                              createInlineLiteral: (resourcePath: string) => ts.LiteralExpression  | undefined): ReplaceNodeOperation[] {\n  const replacements: ReplaceNodeOperation[] = [];\n\n  // Find all object literals.\n  collectDeepNodes<ts.ObjectLiteralExpression>(sourceFile, ts.SyntaxKind.ObjectLiteralExpression)\n  // Get all their property assignments.\n    .map(node => collectDeepNodes<ts.PropertyAssignment>(node, ts.SyntaxKind.PropertyAssignment))\n    // Flatten into a single array (from an array of array<property assignments>).\n    .reduce((prev, curr) => curr ? prev.concat(curr) : prev, [])\n    // We only want property assignments for the templateUrl/styleUrls keys.\n    .filter((node: ts.PropertyAssignment) => {\n      const key = _getContentOfKeyLiteral(node.name);\n      if (!key) {\n        // key is an expression, can't do anything.\n        return false;\n      }\n      return key == 'templateUrl' || key == 'styleUrls';\n    })\n    // Replace templateUrl/styleUrls key with template/styles, and and paths with require('path').\n    .forEach((node: ts.PropertyAssignment) => {\n      const key = _getContentOfKeyLiteral(node.name);\n\n      if (key == 'templateUrl') {\n        const resourcePath = _getResourceRequest(node.initializer, sourceFile);\n        const inlineLiteral = createInlineLiteral(resourcePath.resolved);\n\n        if (!inlineLiteral) {\n          const fileName = Path.relative(process.cwd(), sourceFile.fileName);\n          throw new Error(`Could not find templateUrl expression \"${resourcePath.raw}\" in \"${fileName}\"`);\n        }\n\n        const propAssign = ts.createPropertyAssignment('template', inlineLiteral);\n\n        replacements.push(new ReplaceNodeOperation(sourceFile, node, propAssign));\n      } else if (key == 'styleUrls') {\n        const arr = collectDeepNodes<ts.ArrayLiteralExpression>(node, ts.SyntaxKind.ArrayLiteralExpression);\n\n        if (!arr || arr.length == 0 || arr[0].elements.length == 0) {\n          return;\n        }\n\n        const styleLiterals: ts.Expression[] = [];\n        arr[0].elements.forEach((element: ts.Expression) => {\n          const resourcePath = _getResourceRequest(element, sourceFile);\n          const inlineLiteral = createInlineLiteral(resourcePath.resolved);\n\n          if (!inlineLiteral) {\n            const fileName = Path.relative(process.cwd(), sourceFile.fileName);\n            throw new Error(`Could not find styleUrl expression \"${resourcePath.raw}\" in \"${fileName}\"`);\n          }\n\n          styleLiterals.push(inlineLiteral);\n        });\n\n        const propAssign = ts.createPropertyAssignment('styles', ts.createArrayLiteral(styleLiterals));\n        replacements.push(new ReplaceNodeOperation(sourceFile, node, propAssign));\n      }\n    });\n\n  return replacements;\n\n}\n\nfunction _getContentOfKeyLiteral(node?: ts.Node): string | null {\n  if (!node) {\n    return null;\n  } else if (node.kind == ts.SyntaxKind.Identifier) {\n    return (node as ts.Identifier).text;\n  } else if (node.kind == ts.SyntaxKind.StringLiteral) {\n    return (node as ts.StringLiteral).text;\n  } else {\n    return null;\n  }\n}\n\nfunction _getResourceRequest(element: ts.Expression, sourceFile: ts.SourceFile): { raw: string, resolved: string } {\n  if (element.kind == ts.SyntaxKind.StringLiteral) {\n    let url = (element as ts.StringLiteral).text;\n    // If the URL does not start with / OR ./ OR ../, prepends ./ to it.\n    if (! (/(^\\.?\\.\\/)|(^\\/)/.test(url)) ) {\n      url = './' + url;\n    }\n    return {\n      raw: (element as ts.StringLiteral).text,\n      resolved: resolveResourcePath(url, sourceFile)\n    };\n  } else {\n    throw new Error('Expressions are not supported when inlining resources.')\n  }\n}\n\nfunction resolveResourcePath(fileName: string, sourceFile: ts.SourceFile): string {\n  if (fileName[0] === '/') {\n    return fileName;\n  } else {\n    const dir = Path.dirname(sourceFile.fileName);\n    return Path.resolve(dir, fileName);\n  }\n}\n\nfunction createInlineLiteralFactory(getResource: (resourcePath: string) => string | undefined) {\n  return (resourcePath: string): ts.LiteralExpression | undefined => {\n    const inlineContent = getResource(resourcePath);\n    return inlineContent ? ts.createLiteral(inlineContent) : undefined;\n  }\n}\n"]}