"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// @ignoreDep typescript
var Path = require("path");
var ts = require("typescript");
var ast_helpers_1 = require("./fw/ast_helpers");
var make_transform_1 = require("./fw/make_transform");
var interfaces_1 = require("./fw/interfaces");
function inlineResources(getResource, shouldTransform) {
    var createInlineLiteral = createInlineLiteralFactory(getResource);
    var standardTransform = function (sourceFile) {
        if (!shouldTransform(sourceFile.fileName)) {
            return [];
        }
        return findResources(sourceFile, createInlineLiteral);
    };
    return make_transform_1.makeTransform(standardTransform);
}
exports.inlineResources = inlineResources;
function findResources(sourceFile, createInlineLiteral) {
    var replacements = [];
    // Find all object literals.
    ast_helpers_1.collectDeepNodes(sourceFile, ts.SyntaxKind.ObjectLiteralExpression)
        .map(function (node) { return ast_helpers_1.collectDeepNodes(node, ts.SyntaxKind.PropertyAssignment); })
        .reduce(function (prev, curr) { return curr ? prev.concat(curr) : prev; }, [])
        .filter(function (node) {
        var key = _getContentOfKeyLiteral(node.name);
        if (!key) {
            // key is an expression, can't do anything.
            return false;
        }
        return key == 'templateUrl' || key == 'styleUrls';
    })
        .forEach(function (node) {
        var key = _getContentOfKeyLiteral(node.name);
        if (key == 'templateUrl') {
            var resourcePath = _getResourceRequest(node.initializer, sourceFile);
            var inlineLiteral = createInlineLiteral(resourcePath.resolved);
            if (!inlineLiteral) {
                var fileName = Path.relative(process.cwd(), sourceFile.fileName);
                throw new Error("Could not find templateUrl expression \"" + resourcePath.raw + "\" in \"" + fileName + "\"");
            }
            var propAssign = ts.createPropertyAssignment('template', inlineLiteral);
            replacements.push(new interfaces_1.ReplaceNodeOperation(sourceFile, node, propAssign));
        }
        else if (key == 'styleUrls') {
            var arr = ast_helpers_1.collectDeepNodes(node, ts.SyntaxKind.ArrayLiteralExpression);
            if (!arr || arr.length == 0 || arr[0].elements.length == 0) {
                return;
            }
            var styleLiterals_1 = [];
            arr[0].elements.forEach(function (element) {
                var resourcePath = _getResourceRequest(element, sourceFile);
                var inlineLiteral = createInlineLiteral(resourcePath.resolved);
                if (!inlineLiteral) {
                    var fileName = Path.relative(process.cwd(), sourceFile.fileName);
                    throw new Error("Could not find styleUrl expression \"" + resourcePath.raw + "\" in \"" + fileName + "\"");
                }
                styleLiterals_1.push(inlineLiteral);
            });
            var propAssign = ts.createPropertyAssignment('styles', ts.createArrayLiteral(styleLiterals_1));
            replacements.push(new interfaces_1.ReplaceNodeOperation(sourceFile, node, propAssign));
        }
    });
    return replacements;
}
exports.findResources = findResources;
function _getContentOfKeyLiteral(node) {
    if (!node) {
        return null;
    }
    else if (node.kind == ts.SyntaxKind.Identifier) {
        return node.text;
    }
    else if (node.kind == ts.SyntaxKind.StringLiteral) {
        return node.text;
    }
    else {
        return null;
    }
}
function _getResourceRequest(element, sourceFile) {
    if (element.kind == ts.SyntaxKind.StringLiteral) {
        var url = element.text;
        // If the URL does not start with / OR ./ OR ../, prepends ./ to it.
        if (!(/(^\.?\.\/)|(^\/)/.test(url))) {
            url = './' + url;
        }
        return {
            raw: element.text,
            resolved: resolveResourcePath(url, sourceFile)
        };
    }
    else {
        throw new Error('Expressions are not supported when inlining resources.');
    }
}
function resolveResourcePath(fileName, sourceFile) {
    if (fileName[0] === '/') {
        return fileName;
    }
    else {
        var dir = Path.dirname(sourceFile.fileName);
        return Path.resolve(dir, fileName);
    }
}
function createInlineLiteralFactory(getResource) {
    return function (resourcePath) {
        var inlineContent = getResource(resourcePath);
        return inlineContent ? ts.createLiteral(inlineContent) : undefined;
    };
}
//# sourceMappingURL=inline-resources.js.map