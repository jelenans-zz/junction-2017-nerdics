{"version":3,"file":"make_transform.js","sourceRoot":"","sources":["../../../../../src/cli/transformers/fw/make_transform.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\n\nimport {\n  OPERATION_KIND,\n  StandardTransform,\n  TransformOperation,\n  RemoveNodeOperation,\n  AddNodeOperation,\n  ReplaceNodeOperation,\n} from './interfaces';\n\n\n// instead of adding `semver` package:\nfunction satisfies(tsVersion: string) {\n  const version = tsVersion.split('.').map( v => Number(v) );\n  return version[0] > 2 || (version[0] === 2 && version[1] >= 5);\n}\n\n\n// Typescript below 2.5.0 needs a workaround.\nconst visitEachChild = satisfies(ts.version)\n  ? ts.visitEachChild\n  : visitEachChildWorkaround;\n\nexport function makeTransform(\n  standardTransform: StandardTransform\n): ts.TransformerFactory<ts.SourceFile> {\n\n  return (context: ts.TransformationContext): ts.Transformer<ts.SourceFile> => {\n    const transformer: ts.Transformer<ts.SourceFile> = (sf: ts.SourceFile) => {\n\n      const ops: TransformOperation[] = standardTransform(sf);\n      const removeOps = ops\n        .filter((op) => op.kind === OPERATION_KIND.Remove) as RemoveNodeOperation[];\n      const addOps = ops.filter((op) => op.kind === OPERATION_KIND.Add) as AddNodeOperation[];\n      const replaceOps = ops\n        .filter((op) => op.kind === OPERATION_KIND.Replace) as ReplaceNodeOperation[];\n\n      const visitor: ts.Visitor = (node) => {\n        let modified = false;\n        let modifiedNodes = [node];\n        // Check if node should be dropped.\n        if (removeOps.find((op) => op.target === node)) {\n          modifiedNodes = [];\n          modified = true;\n        }\n\n        // Check if node should be replaced (only replaces with first op found).\n        const replace = replaceOps.find((op) => op.target === node);\n        if (replace) {\n          modifiedNodes = [replace.replacement];\n          modified = true;\n        }\n\n        // Check if node should be added to.\n        const add = addOps.filter((op) => op.target === node);\n        if (add.length > 0) {\n          modifiedNodes = [\n            ...add.filter((op) => op.before).map(((op) => op.before)),\n            ...modifiedNodes,\n            ...add.filter((op) => op.after).map(((op) => op.after))\n          ];\n          modified = true;\n        }\n\n        // If we changed anything, return modified nodes without visiting further.\n        if (modified) {\n          return modifiedNodes;\n        } else {\n          // Otherwise return node as is and visit children.\n          return visitEachChild(node, visitor, context);\n        }\n      };\n\n      // Only visit source files we have ops for.\n      return ops.length > 0 ? ts.visitNode(sf, visitor) : sf;\n    };\n\n    return transformer;\n  };\n}\n\n/**\n * This is a version of `ts.visitEachChild` that works that calls our version\n * of `updateSourceFileNode`, so that typescript doesn't lose type information\n * for property decorators.\n * See https://github.com/Microsoft/TypeScript/issues/17384 and\n * https://github.com/Microsoft/TypeScript/issues/17551, fixed by\n * https://github.com/Microsoft/TypeScript/pull/18051 and released on TS 2.5.0.\n *\n * @param sf\n * @param statements\n */\nfunction visitEachChildWorkaround(node: ts.Node, visitor: ts.Visitor,\n  context: ts.TransformationContext) {\n\n  if (node.kind === ts.SyntaxKind.SourceFile) {\n    const sf = node as ts.SourceFile;\n    const statements = ts.visitLexicalEnvironment(sf.statements, visitor, context);\n\n    if (statements === sf.statements) {\n      return sf;\n    }\n    // Note: Need to clone the original file (and not use `ts.updateSourceFileNode`)\n    // as otherwise TS fails when resolving types for decorators.\n    const sfClone = ts.getMutableClone(sf);\n    sfClone.statements = statements;\n    return sfClone;\n  }\n\n  return ts.visitEachChild(node, visitor, context);\n}\n"]}