"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var path = require("path");
var ts = require("typescript");
var compiler_cli_1 = require("@angular/compiler-cli");
var tsickle = require("tsickle");
exports.GENERATED_FILES = /(.*?)\.(ngfactory|shim\.ngstyle|ngstyle|ngsummary)\.(js|d\.ts|ts)$/;
exports.DTS = /\.d\.ts$/;
function parseDiagnostics(allDiagnostics, options) {
    var result = { exitCode: compiler_cli_1.exitCodeFromResult(allDiagnostics) };
    var errorsAndWarnings = compiler_cli_1.filterErrorsAndWarnings(allDiagnostics);
    if (errorsAndWarnings.length) {
        var currentDir_1 = options ? options.basePath : undefined;
        var formatHost = {
            getCurrentDirectory: function () { return currentDir_1 || ts.sys.getCurrentDirectory(); },
            getCanonicalFileName: function (fileName) { return fileName; },
            getNewLine: function () { return ts.sys.newLine; }
        };
        result.error = new Error(compiler_cli_1.formatDiagnostics(errorsAndWarnings, formatHost));
    }
    return result;
}
exports.parseDiagnostics = parseDiagnostics;
exports.defaultEmitCallback = function (_a) {
    var program = _a.program, targetSourceFile = _a.targetSourceFile, writeFile = _a.writeFile, cancellationToken = _a.cancellationToken, emitOnlyDtsFiles = _a.emitOnlyDtsFiles, customTransformers = _a.customTransformers;
    return program.emit(targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers);
};
function createTsickleEmitCallback(options) {
    var transformDecorators = options.annotationsAs !== 'decorators';
    var transformTypesToClosure = options.annotateForClosureCompiler;
    if (!transformDecorators && !transformTypesToClosure) {
        return undefined;
    }
    if (transformDecorators) {
        // This is needed as a workaround for https://github.com/angular/tsickle/issues/635
        // Otherwise tsickle might emit references to non imported values
        // as TypeScript elided the import.
        options.emitDecoratorMetadata = true;
    }
    var tsickleHost = {
        shouldSkipTsickleProcessing: function (fileName) { return exports.DTS.test(fileName) || exports.GENERATED_FILES.test(fileName); },
        pathToModuleName: function (context, importPath) { return ''; },
        shouldIgnoreWarningsForPath: function (filePath) { return false; },
        fileNameToModuleId: function (fileName) { return fileName; },
        googmodule: false,
        untyped: true,
        convertIndexImportShorthand: false, transformDecorators: transformDecorators, transformTypesToClosure: transformTypesToClosure,
    };
    return function (_a) {
        var program = _a.program, targetSourceFile = _a.targetSourceFile, writeFile = _a.writeFile, cancellationToken = _a.cancellationToken, emitOnlyDtsFiles = _a.emitOnlyDtsFiles, _b = _a.customTransformers, customTransformers = _b === void 0 ? {} : _b, host = _a.host, options = _a.options;
        return tsickle.emitWithTsickle(program, tsickleHost, host, options, targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, {
            beforeTs: customTransformers.before,
            afterTs: customTransformers.after,
        });
    };
}
exports.createTsickleEmitCallback = createTsickleEmitCallback;
/**
 * Returns a function that can adjust a path from source path to out path,
 * based on an existing mapping from source to out path.
 *
 * TODO(tbosch): talk to the TypeScript team to expose their logic for calculating the `rootDir`
 * if none was specified.
 *
 * Note: This function works on normalized paths from typescript.
 *
 * @param outDir
 * @param outSrcMappings
 */
function createSrcToOutPathMapper(outDir, sampleSrcFileName, sampleOutFileName, host) {
    if (host === void 0) { host = path; }
    var srcToOutPath;
    if (outDir) {
        var path_1 = {}; // Ensure we error if we use `path` instead of `host`.
        if (sampleSrcFileName == null || sampleOutFileName == null) {
            throw new Error("Can't calculate the rootDir without a sample srcFileName / outFileName. ");
        }
        var srcFileDir = normalizeSeparators(host.dirname(sampleSrcFileName));
        var outFileDir = normalizeSeparators(host.dirname(sampleOutFileName));
        if (srcFileDir === outFileDir) {
            return function (srcFileName) { return srcFileName; };
        }
        // calculate the common suffix, stopping
        // at `outDir`.
        var srcDirParts = srcFileDir.split('/');
        var outDirParts = normalizeSeparators(host.relative(outDir, outFileDir)).split('/');
        var i = 0;
        while (i < Math.min(srcDirParts.length, outDirParts.length) &&
            srcDirParts[srcDirParts.length - 1 - i] === outDirParts[outDirParts.length - 1 - i])
            i++;
        var rootDir_1 = srcDirParts.slice(0, srcDirParts.length - i).join('/');
        srcToOutPath = function (srcFileName, reverse) { return reverse
            ? host.resolve(rootDir_1, host.relative(outDir, srcFileName))
            : host.resolve(outDir, host.relative(rootDir_1, srcFileName)); };
    }
    else {
        srcToOutPath = function (srcFileName) { return srcFileName; };
    }
    return srcToOutPath;
}
exports.createSrcToOutPathMapper = createSrcToOutPathMapper;
function normalizeSeparators(path) {
    return path.replace(/\\/g, '/');
}
//# sourceMappingURL=util.js.map