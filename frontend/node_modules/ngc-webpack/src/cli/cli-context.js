"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var FS = require("fs");
var Path = require("path");
var resource_loader_1 = require("../resource-loader");
var util_1 = require("./util");
var cli_compiler_host_1 = require("./cli-compiler-host");
var inline_resources_1 = require("./transformers/inline-resources");
var inline_metadata_1 = require("./inline-metadata");
function createCliContext(config) {
    var sourceToOutMapper;
    var compilerHost = new cli_compiler_host_1.CliCompilerHost(config.options, new resource_loader_1.WebpackResourceLoader());
    var getResource = function (resourcePath) { return compilerHost.getResource(resourcePath); };
    var realEmitCallback = util_1.createTsickleEmitCallback(config.options); // defaultEmitCallback;
    var inlineMetadataModule = function (fileName, data) {
        var metadataBundle = JSON.parse(data);
        var relativeTo = Path.dirname(fileName);
        if (sourceToOutMapper) {
            relativeTo = sourceToOutMapper(relativeTo, true);
        }
        // process the metadata bundle and inline resources
        // we send the source location as the relative folder (not the dest) so matching resource paths
        // with compilerHost will work.
        metadataBundle.forEach(function (m) { return inline_metadata_1.inlineMetadataBundle(relativeTo, m, getResource); });
        return JSON.stringify(metadataBundle);
    };
    var emitCallback = function (emitArgs) {
        var writeFile = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            // we don't need to collect all source files mappings, we need only 1 so it's a bit different
            // from angular's code
            if (!sourceToOutMapper) {
                var outFileName = args[0];
                var sourceFiles = args[4];
                if (sourceFiles && sourceFiles.length == 1) {
                    sourceToOutMapper = util_1.createSrcToOutPathMapper(config.options.outDir, sourceFiles[0].fileName, outFileName);
                }
            }
            return emitArgs.writeFile.apply(null, args);
        };
        return realEmitCallback(Object.create(emitArgs, { writeFile: { value: writeFile } }));
    };
    return {
        compilerHost: compilerHost,
        createCompilation: function (compiler) {
            var compilation = compiler.createCompilation();
            compilerHost.resourceLoader.update(compilation);
            return compilation;
        },
        getResource: getResource,
        createInlineResourcesTransformer: function () {
            return inline_resources_1.inlineResources(getResource, function (fileName) { return !fileName.endsWith('.ngfactory.ts') && !fileName.endsWith('.ngstyle.ts'); });
        },
        emitCallback: emitCallback,
        /**
         * Returns a compilerHost instance that inline all resources (templateUrl, styleUrls) inside metadata files that was
         * created for a specific module (i.e. not a flat metadata bundle module)
         *
         */
        resourceInliningCompilerHost: function () {
            return Object.create(compilerHost, {
                writeFile: {
                    writable: true,
                    value: function (fileName, data) {
                        var args = [];
                        for (var _i = 2; _i < arguments.length; _i++) {
                            args[_i - 2] = arguments[_i];
                        }
                        if (/\.metadata\.json$/.test(fileName)) {
                            data = inlineMetadataModule(fileName, data);
                        }
                        return compilerHost.writeFile(fileName, data, args[0], args[1], args[2]);
                    }
                }
            });
        },
        inlineFlatModuleMetadataBundle: function (relativeTo, flatModuleOutFile) {
            var metadataPath = Path.resolve(relativeTo, flatModuleOutFile.replace(/\.js$/, '.metadata.json'));
            if (sourceToOutMapper) {
                metadataPath = sourceToOutMapper(metadataPath);
            }
            if (!FS.existsSync(metadataPath)) {
                throw new Error("Could not find flat module \"metadata.json\" output at " + metadataPath);
            }
            var metadataBundle = JSON.parse(FS.readFileSync(metadataPath, { encoding: 'utf8' }));
            // process the metadata bundle and inline resources
            // we send the source location as the relative folder (not the dest) so matching resource paths
            // with compilerHost will work.
            inline_metadata_1.inlineMetadataBundle(relativeTo, metadataBundle, getResource);
            FS.writeFileSync(metadataPath, JSON.stringify(metadataBundle), { encoding: 'utf8' });
        }
    };
}
exports.createCliContext = createCliContext;
//# sourceMappingURL=cli-context.js.map